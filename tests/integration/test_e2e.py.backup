#!/usr/bin/env python3
"""
End-to-end integration test for TaskWarrior ↔ CalDAV synchronization.

This test runs in CI/CD with Docker containers for Radicale and TaskWarrior.
Configuration is provided via environment variables.
"""

import json
import os
import subprocess
import sys
import time
from datetime import UTC, datetime
from pathlib import Path

import caldav
import pytest
from icalendar import Calendar, Todo

# Configuration from environment variables
CALDAV_URL = os.getenv("CALDAV_URL", "http://localhost:5232/test-user/")
CALDAV_USERNAME = os.getenv("CALDAV_USERNAME", "test-user")
CALDAV_PASSWORD = os.getenv("CALDAV_PASSWORD", "test-pass")
CALDAV_CALENDAR_ID = os.getenv("CALDAV_CALENDAR_ID", "test-calendar")
TW_PROJECT = os.getenv("TW_PROJECT", "test")
TASKDATA = os.getenv("TASKDATA", None)

# Multi-client test configuration
TASKDATA_CLIENT1 = os.getenv("TASKDATA_CLIENT1", "/tmp/tw-client1")
TASKDATA_CLIENT2 = os.getenv("TASKDATA_CLIENT2", "/tmp/tw-client2")


class Colors:
    """ANSI color codes for terminal output."""

    GREEN = "\033[92m"
    RED = "\033[91m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    BOLD = "\033[1m"
    RESET = "\033[0m"


def print_section(title):
    """Print a section header."""
    print(f"\n{Colors.BOLD}{Colors.BLUE}{'=' * 70}{Colors.RESET}")
    print(f"{Colors.BOLD}{Colors.BLUE}{title:^70}{Colors.RESET}")
    print(f"{Colors.BOLD}{Colors.BLUE}{'=' * 70}{Colors.RESET}\n")


def print_success(message):
    """Print success message."""
    print(f"{Colors.GREEN}✓ {message}{Colors.RESET}")


def print_error(message):
    """Print error message."""
    print(f"{Colors.RED}✗ {message}{Colors.RESET}")


def print_info(message):
    """Print info message."""
    print(f"{Colors.YELLOW}→ {message}{Colors.RESET}")


def run_task_command(args):
    """Run a TaskWarrior command and return output."""
    cmd = ["task", *args]
    env = os.environ.copy()
    if TASKDATA:
        env["TASKDATA"] = TASKDATA
        cmd.insert(1, f"rc.data.location={TASKDATA}")

    print_info(f"Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True, env=env)
    return result.stdout, result.stderr, result.returncode


def get_tw_tasks():
    """Get all pending tasks from TaskWarrior test project."""
    stdout, _, _ = run_task_command(
        ["project:" + TW_PROJECT, "status:pending", "export"]
    )
    if not stdout.strip():
        return []
    return json.loads(stdout)


def create_tw_task(description, **kwargs):
    """Create a task in TaskWarrior."""
    args = ["add", description, "project:" + TW_PROJECT]

    if "due" in kwargs:
        args.append(f"due:{kwargs['due']}")
    if "priority" in kwargs:
        args.append(f"priority:{kwargs['priority']}")

    _stdout, stderr, code = run_task_command(args)

    if code != 0:
        print_error(f"Failed to create task: {stderr}")
        return None

    # Extract UUID from output
    tasks = get_tw_tasks()
    if tasks:
        # Return the most recently created task
        return max(tasks, key=lambda t: t.get("entry", ""))
    return None


def modify_tw_task(uuid, **modifications):
    """Modify a TaskWarrior task."""
    args = ["rc.confirmation=off", uuid, "modify"]

    for key, value in modifications.items():
        if key == "description":
            args.append(value)
        else:
            args.append(f"{key}:{value}")

    _stdout, _stderr, code = run_task_command(args)
    return code == 0


def complete_tw_task(uuid):
    """Mark a TaskWarrior task as done."""
    _stdout, _stderr, code = run_task_command(["rc.confirmation=off", uuid, "done"])
    return code == 0


def delete_tw_task(uuid):
    """Delete a TaskWarrior task."""
    _stdout, _stderr, code = run_task_command(["rc.confirmation=off", uuid, "delete"])
    return code == 0


def get_caldav_client():
    """Create CalDAV client connection."""
    try:
        client = caldav.DAVClient(
            url=CALDAV_URL, username=CALDAV_USERNAME, password=CALDAV_PASSWORD
        )
        principal = client.principal()
        return client, principal
    except Exception as e:
        print_error(f"Failed to connect to CalDAV: {e}")
        return None, None


def get_caldav_calendar(principal):
    """Get the test calendar."""
    try:
        calendars = principal.calendars()
        for cal in calendars:
            if cal.id == CALDAV_CALENDAR_ID or CALDAV_CALENDAR_ID in str(cal.url):
                return cal
        print_error(f"Calendar {CALDAV_CALENDAR_ID} not found")
        return None
    except Exception as e:
        print_error(f"Failed to get calendar: {e}")
        return None


def get_caldav_todos(calendar):
    """Get all todos from CalDAV calendar."""
    try:
        return calendar.todos()
    except Exception as e:
        print_error(f"Failed to get todos: {e}")
        return []


def create_caldav_todo(calendar, summary, **kwargs):
    """Create a todo in CalDAV calendar."""
    try:
        cal = Calendar()
        todo = Todo()

        todo.add("summary", summary)
        todo.add("status", kwargs.get("status", "NEEDS-ACTION"))
        todo.add("uid", f"test-{datetime.now().timestamp()}")

        if "due" in kwargs:
            todo.add("due", kwargs["due"])
        if "priority" in kwargs:
            todo.add("priority", kwargs["priority"])
        if "description" in kwargs:
            todo.add("description", kwargs["description"])

        cal.add_component(todo)

        calendar.save_todo(cal.to_ical())
        print_success(f"Created CalDAV todo: {summary}")
        return True
    except Exception as e:
        print_error(f"Failed to create CalDAV todo: {e}")
        return False


def run_sync(dry_run=False, taskdata_override=None, delete_tasks=True):
    """Run the twcaldav sync.

    Args:
        dry_run: If True, run in dry-run mode.
        taskdata_override: Optional TASKDATA path to use instead of default.
        delete_tasks: If True, allow task deletion during sync.
    """
    # Create config file for CI environment
    config_path = Path("/tmp/twcaldav-ci-config.toml")
    config_content = f"""[caldav]
url = "{CALDAV_URL.rstrip("/")}"
username = "{CALDAV_USERNAME}"
password = "{CALDAV_PASSWORD}"

[[mappings]]
taskwarrior_project = "{TW_PROJECT}"
caldav_calendar = "{CALDAV_CALENDAR_ID}"

[sync]
delete_tasks = {str(delete_tasks).lower()}
"""
    config_path.write_text(config_content)

    args = ["uv", "run", "twcaldav", "--config", str(config_path)]
    if dry_run:
        args.append("--dry-run")

    print_info(f"Running sync: {' '.join(args)}")
    env = os.environ.copy()
    taskdata_path = taskdata_override or TASKDATA
    if taskdata_path:
        env["TASKDATA"] = taskdata_path
    result = subprocess.run(args, cwd="/app" if Path("/app").exists() else ".", env=env)
    return result.returncode == 0


def setup_client_taskdata(client_path):
    """Set up a TaskWarrior data directory for a client.

    Args:
        client_path: Path to the client's TASKDATA directory.
    """
    client_dir = Path(client_path)

    # Clean up existing data directory to start fresh
    if client_dir.exists():
        import shutil

        shutil.rmtree(client_dir)

    client_dir.mkdir(parents=True, exist_ok=True)

    # Create a .taskrc file with UDA configuration
    taskrc_path = client_dir / "taskrc"
    taskrc_content = """# TaskWarrior configuration for multi-client testing
data.location={data_dir}

# UDA for CalDAV synchronization
uda.caldav_uid.type=string
uda.caldav_uid.label=CalDAV UID

# Disable confirmation prompts
confirmation=off
"""
    taskrc_path.write_text(taskrc_content.format(data_dir=client_path))
    print_info(f"Created TaskWarrior config at {taskrc_path}")

    return str(taskrc_path)


def run_client_task_command(client_path, args):
    """Run a TaskWarrior command for a specific client.

    Args:
        client_path: Path to the client's TASKDATA directory.
        args: Command arguments to pass to task.

    Returns:
        Tuple of (stdout, stderr, returncode).
    """
    cmd = ["task", f"rc.data.location={client_path}", *args]
    env = os.environ.copy()

    print_info(f"Running (client): {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True, env=env)
    return result.stdout, result.stderr, result.returncode


def get_client_tasks(client_path):
    """Get all pending tasks from a specific client.

    Args:
        client_path: Path to the client's TASKDATA directory.

    Returns:
        List of task dictionaries.
    """
    stdout, _, _ = run_client_task_command(
        client_path, ["project:" + TW_PROJECT, "status:pending", "export"]
    )
    if not stdout.strip():
        return []
    return json.loads(stdout)


def create_client_task(client_path, description, **kwargs):
    """Create a task in a specific client.

    Args:
        client_path: Path to the client's TASKDATA directory.
        description: Task description.
        **kwargs: Additional task attributes (due, priority, etc.).

    Returns:
        The created task dictionary or None.
    """
    args = ["add", description, "project:" + TW_PROJECT]

    if "due" in kwargs:
        args.append(f"due:{kwargs['due']}")
    if "priority" in kwargs:
        args.append(f"priority:{kwargs['priority']}")

    _stdout, stderr, code = run_client_task_command(client_path, args)

    if code != 0:
        print_error(f"Failed to create task: {stderr}")
        return None

    # Get the most recently created task
    tasks = get_client_tasks(client_path)
    if tasks:
        return max(tasks, key=lambda t: t.get("entry", ""))
    return None


def modify_client_task(client_path, uuid, **modifications):
    """Modify a task in a specific client.

    Args:
        client_path: Path to the client's TASKDATA directory.
        uuid: Task UUID.
        **modifications: Modifications to apply.

    Returns:
        True if successful, False otherwise.
    """
    args = ["rc.confirmation=off", uuid, "modify"]

    for key, value in modifications.items():
        if key == "description":
            args.append(value)
        else:
            args.append(f"{key}:{value}")

    _stdout, _stderr, code = run_client_task_command(client_path, args)
    return code == 0


def delete_client_task(client_path, uuid):
    """Delete a task in a specific client.

    Args:
        client_path: Path to the client's TASKDATA directory.
        uuid: Task UUID.

    Returns:
        True if successful, False otherwise.
    """
    _stdout, _stderr, code = run_client_task_command(
        client_path, ["rc.confirmation=off", uuid, "delete"]
    )
    return code == 0


def clear_test_data():
    """Clear all test data from TaskWarrior and CalDAV."""
    print_section("CLEANUP: Clearing Test Data")

    # Clear TaskWarrior
    result = subprocess.run(
        [
            "task",
            f"rc.data.location={TASKDATA}" if TASKDATA else "",
            "project:test",
            "rc.verbose=nothing",
            "export",
        ],
        capture_output=True,
        text=True,
    )

    if result.stdout.strip():
        tasks_to_clear = json.loads(result.stdout)
        print_info(f"Found {len(tasks_to_clear)} tasks to clear (all statuses)")

        for task in tasks_to_clear:
            uuid = task.get("uuid")
            status = task.get("status", "")
            if uuid:
                if status == "deleted":
                    continue
                if status == "completed":
                    subprocess.run(
                        [
                            "task",
                            f"rc.data.location={TASKDATA}" if TASKDATA else "",
                            "rc.confirmation=off",
                            "rc.verbose=nothing",
                            uuid,
                            "delete",
                        ],
                        capture_output=True,
                        text=True,
                    )
                else:
                    subprocess.run(
                        [
                            "task",
                            f"rc.data.location={TASKDATA}" if TASKDATA else "",
                            "rc.confirmation=off",
                            "rc.verbose=nothing",
                            uuid,
                            "delete",
                        ],
                        capture_output=True,
                        text=True,
                    )
    else:
        print_info("No tasks found to clear")

    # Purge deleted tasks
    subprocess.run(
        [
            "task",
            f"rc.data.location={TASKDATA}" if TASKDATA else "",
            "rc.confirmation=off",
            "rc.verbose=nothing",
            "purge",
        ],
        input="y\ny\n",
        capture_output=True,
        text=True,
    )

    tasks = get_tw_tasks()
    print_success(f"Cleared TaskWarrior test project (remaining pending: {len(tasks)})")

    # Clear CalDAV
    _client, principal = get_caldav_client()
    if principal:
        calendar = get_caldav_calendar(principal)
        if calendar:
            todos = get_caldav_todos(calendar)
            count = 0
            for todo in todos:
                try:
                    todo.delete()
                    count += 1
                except Exception as e:
                    print_error(f"Failed to delete todo: {e}")
            print_success(f"Cleared {count} todos from CalDAV")


def verify_initial_state():
    """Verify both TaskWarrior and CalDAV are empty."""
    print_section("PHASE 1: Verify Initial State")

    # Check TaskWarrior
    tasks = get_tw_tasks()
    if len(tasks) == 0:
        print_success("TaskWarrior test project is empty")
    else:
        print_error(f"TaskWarrior has {len(tasks)} tasks, expected 0")
        return False

    # Check CalDAV
    _client, principal = get_caldav_client()
    if not principal:
        return False

    calendar = get_caldav_calendar(principal)
    if not calendar:
        return False

    todos = get_caldav_todos(calendar)
    if len(todos) == 0:
        print_success("CalDAV calendar is empty")
    else:
        print_error(f"CalDAV has {len(todos)} todos, expected 0")
        return False

    return True


def test_tw_to_caldav_create():
    """Test creating tasks in TaskWarrior and syncing to CalDAV."""
    print_section("PHASE 2: TaskWarrior → CalDAV (Create)")

    # Create tasks
    print_info("Creating 3 tasks in TaskWarrior...")
    create_tw_task("Test task 1 - Simple pending")
    create_tw_task("Test task 2 - With due date", due="tomorrow", priority="H")
    task3 = create_tw_task("Test task 3 - Will be completed")

    if task3:
        complete_tw_task(task3["uuid"])

    # Verify in TW (only pending tasks)
    tasks = get_tw_tasks()
    print_success(f"TaskWarrior has {len(tasks)} pending tasks (1 completed)")

    # Run sync (without deletion for this test)
    print_info("\nRunning sync...")
    if not run_sync(delete_tasks=False):
        print_error("Sync failed")
        return False

    # Verify in CalDAV
    # Note: calendar.todos() may not return COMPLETED todos
    _client, principal = get_caldav_client()
    calendar = get_caldav_calendar(principal)
    todos = get_caldav_todos(calendar)

    if len(todos) == 2:
        print_success(f"✓ CalDAV now has {len(todos)} todos (expected 2 pending)")
        return True
    print_error(
        f"CalDAV has {len(todos)} todos, expected 2 (completed task may not be returned"
        " by calendar.todos())"
    )
    return False


def test_caldav_to_tw_create():
    """Test creating todos in CalDAV and syncing to TaskWarrior."""
    print_section("PHASE 3: CalDAV → TaskWarrior (Create)")

    # Get CalDAV client
    _client, principal = get_caldav_client()
    calendar = get_caldav_calendar(principal)

    # Create todos in CalDAV
    print_info("Creating 2 todos in CalDAV...")
    create_caldav_todo(calendar, "CalDAV test todo 1")
    create_caldav_todo(calendar, "CalDAV test todo 2 - High priority", priority=1)

    # Run sync (without deletion for this test)
    print_info("\nRunning sync...")
    if not run_sync(delete_tasks=False):
        print_error("Sync failed")
        return False

    # Verify in TaskWarrior (only pending tasks)
    tasks = get_tw_tasks()
    # Should have 2 original pending + 2 new from CalDAV = 4 pending
    if len(tasks) == 4:
        print_success(f"TaskWarrior now has {len(tasks)} pending tasks (expected 4)")
        return True
    print_error(f"TaskWarrior has {len(tasks)} pending tasks, expected 4")
    return False


def test_tw_to_caldav_modify():
    """Test modifying task in TaskWarrior and syncing to CalDAV."""
    print_section("PHASE 4: TaskWarrior → CalDAV (Modify)")

    # Get a task to modify
    tasks = get_tw_tasks()
    if not tasks:
        print_error("No tasks to modify")
        return False

    task = tasks[0]
    original_desc = task["description"]

    print_info(f"Modifying task: {original_desc}")
    modify_tw_task(task["uuid"], description=f"{original_desc} [MODIFIED]", due="2days")

    # Run sync (without deletion for this test)
    print_info("\nRunning sync...")
    if not run_sync(delete_tasks=False):
        print_error("Sync failed")
        return False

    print_success("Sync completed - verify CalDAV todo was updated")
    return True


def test_caldav_to_tw_modify():
    """Test modifying todo in CalDAV and syncing to TaskWarrior."""
    print_section("PHASE 5: CalDAV → TaskWarrior (Modify)")

    # Get CalDAV client
    _client, principal = get_caldav_client()
    calendar = get_caldav_calendar(principal)

    # Get a CalDAV todo to modify (one we created in phase 3)
    todos = get_caldav_todos(calendar)
    if not todos:
        print_error("No todos to modify")
        return False

    # Find a specific todo to modify
    todo_to_modify = None
    for todo in todos:
        try:
            ical = Calendar.from_ical(todo.data)
            for component in ical.walk():
                if component.name == "VTODO":
                    summary = str(component.get("summary", ""))
                    if "CalDAV test todo 1" in summary:
                        todo_to_modify = todo
                        break
            if todo_to_modify:
                break
        except Exception as e:
            print_error(f"Error parsing todo: {e}")
            continue

    if not todo_to_modify:
        print_error("Could not find 'CalDAV test todo 1' to modify")
        return False

    # Wait before modification to ensure clear timestamp separation from previous sync
    print_info("Waiting 2 seconds to ensure timestamp separation...")
    time.sleep(2)

    # Get the current data and modify it
    try:
        ical = Calendar.from_ical(todo_to_modify.data)
        original_summary = None

        for component in ical.walk():
            if component.name == "VTODO":
                original_summary = str(component.get("summary", ""))
                print_info(f"Modifying CalDAV todo: {original_summary}")

                # Modify the component using the proper icalendar API
                # Delete old properties and add new ones
                if "summary" in component:
                    del component["summary"]
                component.add("summary", f"{original_summary} [MODIFIED IN CALDAV]")

                if "priority" in component:
                    del component["priority"]
                component.add("priority", 3)

                # Update LAST-MODIFIED to ensure sync engine detects the change
                if "last-modified" in component:
                    del component["last-modified"]
                component.add("last-modified", datetime.now(UTC))
                break

        if not original_summary:
            print_error("Could not find VTODO component")
            return False

        # Update the todo with modified data using the caldav library's method
        todo_to_modify.data = ical.to_ical()
        todo_to_modify.save()

        print_success(f"Modified CalDAV todo: {original_summary} [MODIFIED IN CALDAV]")
    except Exception as e:
        print_error(f"Failed to modify CalDAV todo: {e}")
        import traceback

        traceback.print_exc()
        return False

    # Run sync (without deletion for this test)
    print_info("\nRunning sync...")
    if not run_sync(delete_tasks=False):
        print_error("Sync failed")
        return False

    # Verify in TaskWarrior - check if the modification was synced
    tasks = get_tw_tasks()
    found_modified = False
    for task in tasks:
        if "[MODIFIED IN CALDAV]" in task.get("description", ""):
            found_modified = True
            print_success(f"✓ TaskWarrior task updated: {task['description']}")
            break

    if found_modified:
        return True

    print_error("Modified CalDAV todo was not synced to TaskWarrior")
    return False


def test_dry_run():
    """Test dry-run mode."""
    print_section("PHASE 6: Dry-Run Mode")

    # Create a new task
    print_info("Creating new task in TaskWarrior...")
    create_tw_task("Dry run test task - should not sync")

    get_tw_tasks()

    # Get CalDAV todo count before
    _client, principal = get_caldav_client()
    calendar = get_caldav_calendar(principal)
    todos_before = len(get_caldav_todos(calendar))

    # Run sync in dry-run mode (without deletion for this test)
    print_info("\nRunning sync in DRY-RUN mode...")
    run_sync(dry_run=True, delete_tasks=False)

    # Verify CalDAV didn't change
    todos_after = len(get_caldav_todos(calendar))

    if todos_after == todos_before:
        print_success("✓ CalDAV unchanged (dry-run worked)")
        return True
    print_error(f"CalDAV changed: {todos_before} → {todos_after} (dry-run failed)")
    return False


def test_uda_configuration():
    """Test that the required UDA (caldav_uid) is properly configured."""
    print_section("PHASE 0: UDA Configuration")

    stdout, stderr, code = run_task_command(["udas"])

    if code != 0:
        print_error(f"Failed to get UDAs: {stderr}")
        return False

    # Check if caldav_uid UDA is defined
    if "caldav_uid" in stdout:
        print_success("✓ caldav_uid UDA is configured")
        print_info(f"UDA output:\n{stdout[:200]}")
        return True

    print_error("caldav_uid UDA is not configured")
    print_info(f"Available UDAs:\n{stdout}")
    return False


def test_tw_to_caldav_delete():
    """Test deleting task in TaskWarrior and syncing to CalDAV."""
    print_section("PHASE 7: TaskWarrior → CalDAV (Delete)")

    # Get current state
    tasks = get_tw_tasks()
    if not tasks:
        print_error("No tasks available to delete")
        return False

    # Get CalDAV state before deletion
    _client, principal = get_caldav_client()
    calendar = get_caldav_calendar(principal)
    todos_before = len(get_caldav_todos(calendar))

    # Delete a task
    task = tasks[0]
    task_desc = task["description"]
    print_info(f"Deleting task: {task_desc}")

    if not delete_tw_task(task["uuid"]):
        print_error("Failed to delete task")
        return False

    # Run sync
    print_info("\nRunning sync...")
    if not run_sync():
        print_error("Sync failed")
        return False

    # Verify in CalDAV - should have one less todo
    todos_after = len(get_caldav_todos(calendar))

    if todos_after == todos_before - 1:
        print_success(f"✓ CalDAV todo deleted: {todos_before} → {todos_after}")
        return True

    print_error(f"CalDAV todos unchanged: {todos_before} → {todos_after}")
    return False


def test_caldav_to_tw_delete():
    """Test deleting todo in CalDAV and syncing to TaskWarrior."""
    print_section("PHASE 8: CalDAV → TaskWarrior (Delete)")

    # Get CalDAV client
    _client, principal = get_caldav_client()
    calendar = get_caldav_calendar(principal)

    # Get current states
    tasks_before = len(get_tw_tasks())
    todos = get_caldav_todos(calendar)

    if not todos:
        print_error("No todos available to delete")
        return False

    # Delete a CalDAV todo
    todo_to_delete = todos[0]
    try:
        # Get summary for logging
        ical = Calendar.from_ical(todo_to_delete.data)
        summary = "unknown"
        for component in ical.walk():
            if component.name == "VTODO":
                summary = str(component.get("summary", "unknown"))
                break

        print_info(f"Deleting CalDAV todo: {summary}")
        todo_to_delete.delete()
        print_success(f"Deleted CalDAV todo: {summary}")
    except Exception as e:
        print_error(f"Failed to delete CalDAV todo: {e}")
        return False

    # Run sync
    print_info("\nRunning sync...")
    if not run_sync():
        print_error("Sync failed")
        return False

    # Verify in TaskWarrior - should have one less task
    tasks_after = len(get_tw_tasks())

    if tasks_after == tasks_before - 1:
        print_success(f"✓ TaskWarrior task deleted: {tasks_before} → {tasks_after}")
        return True

    print_error(f"TaskWarrior tasks unchanged: {tasks_before} → {tasks_after}")
    return False


def test_multi_client_create():
    """Test task creation synchronization between two TaskWarrior clients."""
    print_section("PHASE 10: Multi-Client (Create)")

    # Setup two clients
    print_info("Setting up two TaskWarrior clients...")
    setup_client_taskdata(TASKDATA_CLIENT1)
    setup_client_taskdata(TASKDATA_CLIENT2)

    # Clear CalDAV to start fresh
    _client, principal = get_caldav_client()
    calendar = get_caldav_calendar(principal)
    for todo in get_caldav_todos(calendar):
        todo.delete()

    # Client 1: Create a task
    print_info("\n[CLIENT 1] Creating a task...")
    task1 = create_client_task(
        TASKDATA_CLIENT1, "Multi-client test task from client 1", priority="H"
    )
    if not task1:
        print_error("Failed to create task in client 1")
        return False
    print_success(f"[CLIENT 1] Created: {task1['description']}")

    # Client 1: Sync to CalDAV
    print_info("\n[CLIENT 1] Syncing to CalDAV...")
    if not run_sync(taskdata_override=TASKDATA_CLIENT1):
        print_error("Client 1 sync failed")
        return False

    # Verify task is in CalDAV
    todos_after_sync = get_caldav_todos(calendar)
    if len(todos_after_sync) != 1:
        print_error(f"Expected 1 todo in CalDAV, found {len(todos_after_sync)}")
        return False
    print_success("✓ Task synced to CalDAV")

    # Client 2: Sync from CalDAV
    print_info("\n[CLIENT 2] Syncing from CalDAV...")
    if not run_sync(taskdata_override=TASKDATA_CLIENT2):
        print_error("Client 2 sync failed")
        return False

    # Verify task appears in Client 2
    client2_tasks = get_client_tasks(TASKDATA_CLIENT2)
    if len(client2_tasks) != 1:
        print_error(f"Expected 1 task in client 2, found {len(client2_tasks)}")
        return False

    if "Multi-client test task from client 1" in client2_tasks[0]["description"]:
        print_success(f"✓ [CLIENT 2] Task synced: {client2_tasks[0]['description']}")
        return True

    print_error("Task not properly synced to client 2")
    return False


def test_multi_client_modify():
    """Test task modification synchronization between two TaskWarrior clients."""
    print_section("PHASE 11: Multi-Client (Modify)")

    # Client 2: Modify the task
    client2_tasks = get_client_tasks(TASKDATA_CLIENT2)
    if not client2_tasks:
        print_error("No tasks in client 2 to modify")
        return False

    task = client2_tasks[0]
    original_desc = task["description"]

    print_info(f"\n[CLIENT 2] Modifying task: {original_desc}")
    # Wait to ensure timestamp separation
    time.sleep(2)
    if not modify_client_task(
        TASKDATA_CLIENT2,
        task["uuid"],
        description=f"{original_desc} [MODIFIED BY CLIENT 2]",
    ):
        print_error("Failed to modify task in client 2")
        return False
    print_success("[CLIENT 2] Modified task")

    # Client 2: Sync to CalDAV
    print_info("\n[CLIENT 2] Syncing to CalDAV...")
    if not run_sync(taskdata_override=TASKDATA_CLIENT2):
        print_error("Client 2 sync failed")
        return False

    # Client 1: Sync from CalDAV
    print_info("\n[CLIENT 1] Syncing from CalDAV...")
    if not run_sync(taskdata_override=TASKDATA_CLIENT1):
        print_error("Client 1 sync failed")
        return False

    # Verify modification appears in Client 1
    client1_tasks = get_client_tasks(TASKDATA_CLIENT1)
    if not client1_tasks:
        print_error("No tasks found in client 1")
        return False

    if "[MODIFIED BY CLIENT 2]" in client1_tasks[0]["description"]:
        print_success(f"✓ [CLIENT 1] Task updated: {client1_tasks[0]['description']}")
        return True

    print_error(
        f"Modification not synced to client 1. Got: {client1_tasks[0]['description']}"
    )
    return False


def test_multi_client_delete():
    """Test task deletion synchronization between two TaskWarrior clients."""
    print_section("PHASE 12: Multi-Client (Delete)")

    # Client 1: Delete the task
    client1_tasks = get_client_tasks(TASKDATA_CLIENT1)
    if not client1_tasks:
        print_error("No tasks in client 1 to delete")
        return False

    task = client1_tasks[0]
    task_desc = task["description"]

    print_info(f"\n[CLIENT 1] Deleting task: {task_desc}")
    if not delete_client_task(TASKDATA_CLIENT1, task["uuid"]):
        print_error("Failed to delete task in client 1")
        return False
    print_success("[CLIENT 1] Deleted task")

    # Client 1: Sync to CalDAV
    print_info("\n[CLIENT 1] Syncing to CalDAV...")
    if not run_sync(taskdata_override=TASKDATA_CLIENT1):
        print_error("Client 1 sync failed")
        return False

    # Client 2: Sync from CalDAV
    print_info("\n[CLIENT 2] Syncing from CalDAV...")
    if not run_sync(taskdata_override=TASKDATA_CLIENT2):
        print_error("Client 2 sync failed")
        return False

    # Verify task is deleted in Client 2
    client2_tasks = get_client_tasks(TASKDATA_CLIENT2)
    if len(client2_tasks) == 0:
        print_success("✓ [CLIENT 2] Task deleted")
        return True

    print_error(f"Task not deleted in client 2. Found {len(client2_tasks)} tasks")
    return False


def test_tw_annotation_create():
    """Test creating TW task with annotation syncs to CalDAV."""
    print_section("PHASE 13: TW → CalDAV (Annotation Create)")

    # Create task with annotation
    task_desc = "Task with annotation"
    print_info(f"\nCreating TW task: {task_desc}")

    task = create_tw_task(task_desc)
    if not task:
        print_error("Failed to create task")
        return False

    task_uuid = task["uuid"]

    # Add annotation to the task
    annotation_text = "This is a test annotation"
    print_info(f"Adding annotation: {annotation_text}")

    # Use task annotate command
    result = run_task_command([task_uuid, "annotate", annotation_text])

    if not result:
        print_error("Failed to add annotation")
        return False

    print_success(f"✓ Added annotation to task {task_uuid}")

    # Sync to CalDAV
    print_info("\nSyncing to CalDAV...")
    if not run_sync():
        print_error("Sync failed")
        return False

    # Verify CalDAV todo has annotation in description
    print_info("\nVerifying CalDAV todo...")
    client, principal = get_caldav_client()
    if not client or not principal:
        print_error("Failed to connect to CalDAV")
        return False

    calendar = get_caldav_calendar(principal)
    if not calendar:
        print_error("Failed to get calendar")
        return False

    todos = get_caldav_todos(calendar)

    # Find the matching todo
    description = None
    for todo in todos:
        try:
            ical = Calendar.from_ical(todo.data)
            for component in ical.walk():
                if component.name == "VTODO":
                    summary = str(component.get("summary", ""))
                    if summary == task_desc:
                        description = str(component.get("description", ""))
                        break
            if description is not None:
                break
        except Exception as e:
            print_error(f"Error parsing todo: {e}")

    if description is None:
        print_error("Task not found in CalDAV")
        return False

    if "--- TaskWarrior Annotations ---" not in description:
        print_error("Annotation marker not found in CalDAV description")
        print_error(f"Description: {description}")
        return False

    if annotation_text not in description:
        print_error(f"Annotation text '{annotation_text}' not found in description")
        print_error(f"Description: {description}")
        return False

    # Check for pipe-delimited format (timestamp|description)
    if "|" not in description:
        print_error("Annotation not in pipe-delimited format")
        print_error(f"Description: {description}")
        return False

    print_success("✓ Annotation synced to CalDAV with correct format")
    return True


def test_caldav_annotation_sync():
    """Test CalDAV todo with annotation syncs to TW."""
    print_section("PHASE 14: CalDAV → TW (Annotation)")

    # Create a CalDAV todo with annotation in description
    task_desc = "CalDAV task with annotation"
    annotation_text = "Annotation from CalDAV"
    timestamp = "20241118T120000Z"

    description_with_annotation = (
        f"--- TaskWarrior Annotations ---\n{timestamp}|{annotation_text}"
    )

    print_info(f"\nCreating CalDAV todo with annotation: {task_desc}")

    client, principal = get_caldav_client()
    if not client or not principal:
        print_error("Failed to connect to CalDAV")
        return False

    calendar = get_caldav_calendar(principal)
    if not calendar:
        print_error("Failed to get calendar")
        return False

    todo_uid = create_caldav_todo(
        calendar, task_desc, description=description_with_annotation
    )
    if not todo_uid:
        print_error("Failed to create CalDAV todo")
        return False

    # Sync from CalDAV
    print_info("\nSyncing from CalDAV...")
    if not run_sync():
        print_error("Sync failed")
        return False

    # Verify TW task has annotation
    print_info("\nVerifying TW task...")
    tasks = get_tw_tasks()

    matching_tasks = [t for t in tasks if t.get("description") == task_desc]
    if not matching_tasks:
        print_error("Task not found in TW")
        return False

    task = matching_tasks[0]

    if "annotations" not in task:
        print_error("Task does not have annotations")
        return False

    annotations = task["annotations"]
    if not isinstance(annotations, list) or len(annotations) == 0:
        print_error(f"Task has no annotations: {annotations}")
        return False

    # Check annotation content
    annotation = annotations[0]
    if annotation.get("description") != annotation_text:
        print_error(
            f"Annotation text mismatch. Expected: '{annotation_text}', "
            f"Got: '{annotation.get('description')}'"
        )
        return False

    if annotation.get("entry") != timestamp:
        print_error(
            f"Annotation timestamp mismatch. Expected: '{timestamp}', "
            f"Got: '{annotation.get('entry')}'"
        )
        return False

    print_success("✓ Annotation synced from CalDAV to TW")
    return True


def test_annotation_deduplication():
    """Test bidirectional annotation sync with deduplication."""
    print_section("PHASE 15: Annotation Deduplication")

    # Create task with annotation in TW
    task_desc = "Task for dedup test"
    annotation1 = "First annotation"

    print_info(f"\nCreating TW task: {task_desc}")
    task = create_tw_task(task_desc)
    if not task:
        print_error("Failed to create task")
        return False

    task_uuid = task["uuid"]

    # Add first annotation
    print_info(f"Adding annotation 1: {annotation1}")
    if not run_task_command([task_uuid, "annotate", annotation1]):
        print_error("Failed to add annotation 1")
        return False

    # Sync to CalDAV
    print_info("\n[SYNC 1] TW → CalDAV")
    if not run_sync():
        print_error("Sync 1 failed")
        return False

    # Sync again (CalDAV → TW) - should not duplicate
    print_info("\n[SYNC 2] CalDAV → TW (should not duplicate)")
    if not run_sync():
        print_error("Sync 2 failed")
        return False

    # Verify still only 1 annotation
    tasks = get_tw_tasks()
    task = [t for t in tasks if t["uuid"] == task_uuid][0]

    if "annotations" not in task:
        print_error("Task lost annotations after sync")
        return False

    if len(task["annotations"]) != 1:
        print_error(
            f"Annotation duplicated! Expected 1, got {len(task['annotations'])}"
        )
        return False

    print_success("✓ No duplication after bidirectional sync")

    # Add second annotation on TW side
    annotation2 = "Second annotation"
    print_info(f"\nAdding annotation 2: {annotation2}")

    if not run_task_command([task_uuid, "annotate", annotation2]):
        print_error("Failed to add annotation 2")
        return False

    # Sync to CalDAV
    print_info("\n[SYNC 3] TW → CalDAV (with new annotation)")
    if not run_sync():
        print_error("Sync 3 failed")
        return False

    # Sync back from CalDAV
    print_info("\n[SYNC 4] CalDAV → TW (should have 2 annotations)")
    if not run_sync():
        print_error("Sync 4 failed")
        return False

    # Verify we have exactly 2 annotations
    tasks = get_tw_tasks()
    task = [t for t in tasks if t["uuid"] == task_uuid][0]

    if len(task["annotations"]) != 2:
        print_error(
            f"Expected 2 annotations, got {len(task['annotations'])}: "
            f"{task['annotations']}"
        )
        return False

    # Verify content
    descriptions = [a["description"] for a in task["annotations"]]
    if annotation1 not in descriptions:
        print_error(f"Annotation 1 '{annotation1}' not found")
        return False

    if annotation2 not in descriptions:
        print_error(f"Annotation 2 '{annotation2}' not found")
        return False

    print_success("✓ Both annotations preserved, no duplicates")
    return True


def main():
    """Run all integration tests."""
    print(f"\n{Colors.BOLD}TaskWarrior ↔ CalDAV Integration Test (CI/CD){Colors.RESET}")
    print(f"CalDAV URL: {CALDAV_URL}")
    print(f"Calendar: {CALDAV_CALENDAR_ID}")
    print(f"Project: {TW_PROJECT}")
    print(f"TaskData: {TASKDATA or 'default'}")

    # Always clean before running tests in CI
    clear_test_data()

    # Run tests
    tests = [
        ("UDA Configuration", test_uda_configuration),
        ("Initial State", verify_initial_state),
        ("TW → CalDAV (Create)", test_tw_to_caldav_create),
        ("CalDAV → TW (Create)", test_caldav_to_tw_create),
        ("TW → CalDAV (Modify)", test_tw_to_caldav_modify),
        ("CalDAV → TW (Modify)", test_caldav_to_tw_modify),
        ("TW → CalDAV (Delete)", test_tw_to_caldav_delete),
        ("CalDAV → TW (Delete)", test_caldav_to_tw_delete),
        ("Dry-Run Mode", test_dry_run),
        ("Multi-Client (Create)", test_multi_client_create),
        ("Multi-Client (Modify)", test_multi_client_modify),
        ("Multi-Client (Delete)", test_multi_client_delete),
        ("TW → CalDAV (Annotation)", test_tw_annotation_create),
        ("CalDAV → TW (Annotation)", test_caldav_annotation_sync),
        ("Annotation Deduplication", test_annotation_deduplication),
    ]

    results = []
    for name, test_func in tests:
        try:
            result = test_func()
            results.append((name, result))
        except Exception as e:
            print_error(f"Test '{name}' raised exception: {e}")
            import traceback

            traceback.print_exc()
            results.append((name, False))

    # Summary
    print_section("TEST SUMMARY")
    passed = sum(1 for _, result in results if result)
    total = len(results)

    for name, result in results:
        status = "PASS" if result else "FAIL"
        color = Colors.GREEN if result else Colors.RED
        print(f"{color}{status:6}{Colors.RESET} {name}")

    print(f"\n{Colors.BOLD}Total: {passed}/{total} passed{Colors.RESET}\n")

    return 0 if passed == total else 1


if __name__ == "__main__":
    sys.exit(main())
